# JWTs in a nutshell
JWTs are encoded tokens that contain claims in the form of JSON objects that are signed such that they cannot be tampered with and can be verified with our secret key to make sure that they are a valid token.



## What can you store in a JWT
In a JWT there are 3 parts that make up the token. 

The Header, The Payload, and The Signature
The token itself is formatted as so:

`xxxx.yyyy.zzzz`

Where the x's are the header, the y's are the payload, and the z's are the signature all separated by .s

<br>


The part we use to store and transfer "claims" (JSON data that we can use) is called the Payload. The other 2 sections of the token are the Headers and the Signature (used for metadata about the token and verifying token validity).


A JWT Payload can be in a form like so:

```json
{
	"name" : "John Doe",
	"email" : "johndoe@email.com",
	"admin" : true
}
```

JWTs are encoded in Base64Url format to compact the information into a smaller space. Base64Url is used so that different machines with different encoder configurations will encode the same way. 
- Notice I said "encoded" not "encrypted" anyone who can get access to your JWT can see the contents of the JWT just by decoding the token, so do not put any data in there that is considered confidential and secret like passwords, etc.

### JWT Headers
Within the headers section of the JWT contains metadata about the token itsself, e.g., the type of token and the signature type

## Steps for Authenticating with JWTs
1. The user submits their username and password to the authentication server
2. The authentication server determines whether there is a user with the given password
3. If no the server rejects the request, if yes the server generates a JWT with its special key and a payload with user information needed by the application, ex. User Id, Token Expiration Date, etc.
4. The browser saves the JWT generated by the server until it expires and sends it to the server whenever it needs to authenticate 
	1. Common practice is to set the expiration time to 15 minutes so stolen JWTs cannot be used, else if someone gains access to other peoples JWTs they can access their data
5. Whenever the JWT is sent for authentication it checks to make sure that the JWT was signed with the correct secret key
	1. The application server knows that someone with a JWT must be safe since the authentication server only gives JWTs to people who have valid username password combinations
	2. The only way someone can impersonate another user is to steal the username password combination or the secret key used to sign every JWT (which is a pretty big deal lmao)
6. Then gets the user info from the Payload of the token and gets data for said user

```mermaid
sequenceDiagram
	participant User
	participant Authentication Server
	participant Application Server
	User->>Authentication Server: Username & Password
	Authentication Server->>User: Signed JWT or Invalid Credentials Notification
	User-->>Application Server: JWT
	Application Server-->>User: Data or Invalid JWT Notification
```

## User Session Management with JWTs
### -Subject and Expiration
Really anything can be put inside a JSON payload, but for the use case of user authentication the main ones we want in there are
- user identification
- session expiration

Example Payload 
```json
{
	"iss": "Identifier of our Authentication Server",

	"iat": 1504699136,

	"sub": "github|353454354354353453",

	"exp": 1504699256
}
```

standard property explanation
- iss: the issuing entity
- iat: the timestamp of creation of the JWT
- sub: the identification for the user
- exp: the expiration timestamp

The above is called the **Bearer Token**, basically it means the authentication server has verified that the user in the sub property is a valid user and we can give that user access to whatever it needed authentication for whether it be data, or endpoint access, etc.

### JWT Signatures

- HS256 vs RS256

HS256 is based on a **cryptographic hashing function**. A hashing function has a few important properties that make it useful when creating a digital signature.

1. Irreversibility
	1. If you put something into the hashing function, it is **impossible** to read the data from the output
2. Reproducibility
	1.  Hashing the same input will **always** give the same output
	2. This is useful because we can easily verify that a pair of inputs and hash outputs are the same by just hashing the inputs and checking to see if it matches the hash output
3. No Collisions
	1. Unique input = Unique output
	2. Each persons user identifiers turns into a unique hash output meaning we can easily identify who is who, there will never be 2 people with the same hash output
4. Unpredictability
	1. You cannot see if two outputs are "close" to each other
	2. On average 50% of the outputs bits will change even with 1 bit being changed in the input

Hashing functions create a signature by hashing the Header, Payload, AND the **secret key that only the signer has access to!** This secret key makes it so that no one can forge a JWT (at least, a JWT that comes from your secret key). Without the secret key there is no way to create a JWT that would come from that secret key.

### How to validate a HS256 JWT signature?
To validate a JWT you need to take the JWT and hash its Payload and Header with your secret key, if that hash matches the hash in the given JWT then that means the JWT was created with your secret key! So either someone stole your secret key (dear god lets hope not), or you created the JWT yourself with your secret key meaning the JWT is valid!

### Disadvantages of HS256 Signatures

1. HS256 signatures can be brute forced if the input secret is weak
2. Requires the existence of a previously agreed secret password between the server that is issuing the JWTs, and any other server machine consuming the JWTs for validation and user identification
3. Changing the secret key requires every server that needs to authenticate to change the secret key as well, this means we need to stop said servers and make sure they have the right key
4. No distinction between the creation of JWTs and the validation of JWTs since everyone has the secret key they can do either
	1. Many more places for an attacker to steal the secret key from

### RS256 JWT Signature
Still going to create a Message Authentication Code (MAC) like before but now we're going to separate the ability to create from the ability to validate. Only the authentication server should be able to actually create new tokens, and only the application server should be able to validate tokens.

To do this we create two keys instead of one:
1. Still a private key but only the authentication server will own it to sign JWTs
2. The **private key can only be used to sign, not validate**
3. The second key, the one used by the application server, will be the public key that we will use to validate the JWT
4. The **public key can validate JWTs but not sign new ones**
5. Since the public key cannot sign new JWTs we don't care if someone gets a hold of it

### RSA encryption
RSA encryption uses one key to encrypt and one key to decrypt. RSA is **NOT** a hashing function as the input can be turned back into readable text.

RSA keys look like this:

```json
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDdlatRjRjogo3WojgGHFHYLugdUWAY9iR3fy4arWNA1KoS8kVw33cJibXr8bvwUAUparCwlvdbH6dvEOfou0/gCFQsHUfQrSDv+MuSUMAe8jzKE4qW+jK+xQU9a03GUnKHkkle+Q0pX/g6jXZ7r1/xAK5Do2kQ+X5xK9cipRgEKwIDAQAB
-----END PUBLIC KEY-----  
```

```json
-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgQDdlatRjRjogo3WojgGHFHYLugdUWAY9iR3fy4arWNA1KoS8kVw33cJibXr8bvwUAUparCwlvdbH6dvEOfou0/gCFQsHUfQrSDv+MuSUMAe8jzKE4qW+jK+xQU9a03GUnKHkkle+Q0pX/g6jXZ7r1/xAK5Do2kQ+X5xK9cipRgEKwIDAQABAoGAD+onAtVye4ic7VR7V50DF9bOnwRwNXrARcDhq9LWNRrRGElESYYTQ6EbatXS3MCyjjX2eMhu/aF5YhXBwkppwxg+EOmXeh+MzL7Zh284OuPbkglAaGhV9bb6/5CpuGb1esyPbYW+Ty2PC0GSZfIXkXs76jXAu9TOBvD0ybc2YlkCQQDywg2R/7t3Q2OE2+yo382CLJdrlSLVROWKwb4tb2PjhY4XAwV8d1vy0RenxTB+K5Mu57uVSTHtrMK0GAtFr833AkEA6avx20OHo61Yela/4k5kQDtjEf1N0LfI+BcWZtxsS3jDM3i1Hp0KSu5rsCPb8acJo5RO26gGVrfAsDcIXKC+bQJAZZ2XIpsitLyPpuiMOvBbzPavd4gY6Z8KWrfYzJoI/Q9FuBo6rKwl4BFoToD7WIUS+hpkagwWiz+6zLoX1dbOZwJACmH5fSSjAkLRi54PKJ8TFUeOP15h9sQzydI8zJU+upvDEKZsZc/UhT/SySDOxQ4G/523Y0sz/OZtSWcol/UMgQJALesy++GdvoIDLfJX5GBQpuFgFenRiRDabxrE9MNUZ2aPFaFp+DyAe+b4nDwuJaW2LURbr8AEZga7oQj0uYxcYw==
-----END RSA PRIVATE KEY-----  
```

### Signing JWTs with RSA and SHA-256
1. First we hash the payload and header
2. Then we encrypt the hash output with our RSA secret key
3. We can then add that as our JWT signature then send it

### Validating JWTs signed with RSA
1. Take the encrypted hash and decrypt it with our public key
2. Then we hash the payload and header that was sent in the JWT
3. If the decrypted hash matches the hash we just created then the key is valid!
	1. Our public key can only decrypt something correctly if it was first encrypted with the correct secret key! This lets us validate whether the JWT was indeed signed by our own secret key, and there is no way to guess the secret key from the public key which is important



### Why RS256?
Brute forcing RSA with a large enough key size is very unfeasible, so the method will be fairly safe for the foreseeable future. Academics have cracked up to ~800 bit length RSA keys but it should be safe as long as your key is >1024 or so.

The main practical reasons for using RS256 is the fact that we can separate the validation and creation of JWTs into two distinct operating servers. Thus we can keep our key safer from attackers trying to penetrate our IT services to *steal* our key which is a much larger threat than someone cracking our key. 

The other main reason is for simplified key rotation.

### How to implement key rotation
Since the public key is... well.. *public* we can have the application server just check for the public key from a published source that we control, and we don't even have to check every time, we can check to see if the key has changed every so often, in case of key rotation or emergency key changes. This allows us to keep the application server running always when we rotate the keys. We only now need to stop the authentication server to rotate and update the keys!

We can publish our public key is a few ways, one possible format is using JWKS (JSON Web Key Set) Endpoints.

These endpoints publish a series of public keys not just one and there are many npm packages that we can use to consume these endpoints and validate JWTs

the response from a JWKS is also standardized and looks like this:

```json
  
{
"keys": [
{
"alg": "RS256",

"kty": "RSA",

"use": "sig",

"x5c": [
"MIIDJTCCAg2gAwIBAgIJUP6A/iwWqvedMA0GCSqGSIb3DQEBCwUAMDAxLjAsBgNVBAMTJWFuZ3VsYXJ1bml2LXNlY3VyaXR5LWNvdXJzZS5hdXRoMC5jb20wHhcNMTcwODI1MTMxNjUzWhcNMzEwNTA0MTMxNjUzWjAwMS4wLAYDVQQDEyVhbmd1bGFydW5pdi1zZWN1cml0eS1jb3Vyc2UuYXV0aDAuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwUvZ+4dkT2nTfCDIwyH9K0tH4qYMGcW/KDYeh+TjBdASUS9cd741C0XMvmVSYGRP0BOLeXeaQaSdKBi8uRWFbfdjwGuB3awvGmybJZ028OF6XsnKH9eh/TQ/8M/aJ/Ft3gBHJmSZCuJ0I3JYSBEUrpCkWjkS5LtyxeCPA+usFAfixPnU5L5lyacj3t+dwdFHdkbXKUPxdVwwkEwfhlW4GJ79hsGaGIxMq6PjJ//TKkGadZxBo8FObdKuy7XrrOvug4FAKe+3H4Y5ZDoZZm5X7D0ec4USjewH1PMDR0N+KUJQMRjVul9EKg3ygyYDPOWVGNh6VC01lZL2Qq244HdxRwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRwgr0c0DYG5+GlZmPRFkg3+xMWizAOBgNVHQ8BAf8EBAMCAoQwDQYJKoZIhvcNAQELBQADggEBACBV4AyYA3bTiYWZvLtYpJuikwArPFD0J5wtAh1zxIVl+XQlR+S3dfcBn+90J8A677lSu0t7Q7qsZdcsrj28BKh5QF1dAUQgZiGfV3Dfe4/P5wUaaUo5Y1wKgFiusqg/mQ+kM3D8XL/Wlpt3p804dbFnmnGRKAJnijsvM56YFSTVO0JhrKv7XeueyX9LpifAVUJh9zFsiYMSYCgBe3NIhIfi4RkpzEwvFIBwtDe2k9gwIrPFJpovZte5uvi1BQAAoVxMuv7yfMmH6D5DVrAkMBsTKXU1z3WdIKbrieiwSDIWg88RD5flreeTDaCzrlgfXyNybi4UTUshbeo6SdkRiGs="
],

"n": "wUvZ-4dkT2nTfCDIwyH9K0tH4qYMGcW_KDYeh-TjBdASUS9cd741C0XMvmVSYGRP0BOLeXeaQaSdKBi8uRWFbfdjwGuB3awvGmybJZ028OF6XsnKH9eh_TQ_8M_aJ_Ft3gBHJmSZCuJ0I3JYSBEUrpCkWjkS5LtyxeCPA-usFAfixPnU5L5lyacj3t-dwdFHdkbXKUPxdVwwkEwfhlW4GJ79hsGaGIxMq6PjJ__TKkGadZxBo8FObdKuy7XrrOvug4FAKe-3H4Y5ZDoZZm5X7D0ec4USjewH1PMDR0N-KUJQMRjVul9EKg3ygyYDPOWVGNh6VC01lZL2Qq244HdxRw",

"e": "AQAB",

"kid": "QzY0NjREMjkyQTI4RTU2RkE4MUJBRDExNzY1MUY1N0I4QjFCODlBOQ",

"x5t": "QzY0NjREMjkyQTI4RTU2RkE4MUJBRDExNzY1MUY1N0I4QjFCODlBOQ"
}
]
}
```

The *kid* property is the key identifier, and *x5c* is the representation of one particular public key

Since the format is standard all we need is the URL to the endpoint and a library that consumes JWKS, this gives us a usable public key to validate our JWTs with!



